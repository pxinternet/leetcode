package leetCode;

/**
 * LC10 正则表达式匹配 (简要中文说明)
 *
 * 本类提供方法 isMatch(s, p)，判断字符串 s 是否匹配模式 p，模式 p 中支持两个特殊字符：
 *  - '.' 匹配任意单个字符
 *  - '*' 匹配零个或多个紧前面的那个元素
 *
 * 下面对实现的动态规划方法做详细中文注释和解释，方便理解与验证正确性。
 */
public class LC10isMatch {

    /**
     * 动态规划解法（中文详细注释）
     *
     * 契约：
     *  - 输入：s（目标字符串），p（模式字符串，包含 '.' 和 '*'）
     *  - 输出：true 如果 s 完全匹配 p（整个字符串匹配），否则 false
     *
     * 思路概述：
     * 采用典型的二维动态规划。
     * 定义状态：dp[i][j] 表示 s 的前 i 个字符（s[0..i-1]）是否能被 p 的前 j  个字符（p[0..j-1]）完全匹配。
     *
     * 状态长度：dp 大小为 (m+1) x (n+1)，其中 m = s.length(), n = p.length()，多一行/列用于表示空串的情况。
     * 初始状态：dp[0][0] = true（空模式匹配空字符串）。
     *
     * 关键初始化：
     * 当 s 为空串（i == 0）时，只有当模式 p 能够表示空串时 dp[0][j] 才为 true。
     * 在模式里，形如 x* 可以匹配 0 个 x，因此需要处理 j 对应的是 '*' 的情况：
     * 对于 j 从 2 开始，每当 p[j-1] == '*' 时，dp[0][j] = dp[0][j-2]（忽略掉 x* 这个两字符）
     * 注意：这里假设模式是合法的（例如不会以 '*' 开头而没有前导元素），与题目约束一致。
     *
     * 状态转移：
     * 对于 i >= 1 且 j >= 1，有两种情况：
     * 1) p[j-1] != '*'（当前模式字符不是 '*')：
     *    - 要想匹配，必须 s 的第 i 个字符和 p 的第 j 个字符能匹配（相等或 p[j-1]=='.'），且 dp[i-1][j-1] 为真。
     *    - 形式化：dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
     *
     * 2) p[j-1] == '*'（模式最后一个字符为 '*'）: 这里 '*' 代表重复前一个元素（记作 x*），它有两类语义：
     *    - 匹配 0 个 x：那么我们可以忽略掉 x* 两个字符，状态变为 dp[i][j-2]
     *    - 匹配 >=1 个 x：那么需要保证 s 的第 i 个字符能被 x（也就是 p[j-2]）匹配，同时之前的状态 dp[i-1][j] 成立（用 '*' 再匹配一个字符）
     *    - 合并：dp[i][j] = dp[i][j-2] || (dp[i-1][j] && match(s[i-1], p[j-2]))
     *    - 其中 match(c, x) 表示字符 c 能和模式字符 x 匹配：c==x 或 x=='.'
     *
     * 直观正确性：
     * - 该状态定义严格对应“前缀匹配”的子问题划分，转移考虑了 '*' 的两种行为（0 次或 >=1 次），以及普通字符/点号的单个匹配。
     * - 通过对所有 i 从 0..m, j 从 0..n 的枚举，最终 dp[m][n] 汇总了整个字符串与整个模式的匹配结果。
     *
     * 时间复杂度：O(m * n)
     * 空间复杂度：O(m * n)（可优化为 O(n) 的一维滚动数组，但当前二维实现更直观）。
     *
     * 常见边界与坑：
     * - 模式以 '*' 开头在题目中不会出现（非法模式），否则访问 p[j-2] 会越界。
     * - 初始化 dp[0][j] 时必须按 j 从小到大，跳跃 2 的步长处理 '*'，否则不能正确表示多个连续 x* 可以删去的情况。
     * - 在循环里访问 s.charAt(i-1) 与 p.charAt(j-2) 时，注意索引防越界（代码中通过循环边界 i=1..m, j=1..n 保证）。
     *
     * 示例验证（手工推理）：
     * - s="aa", p="a" -> dp[2][1] 为 false
     * - s="aa", p="a*" -> dp[2][2] = true（'*' 表示重复 1 次或多次）
     * - s="ab", p=".*" -> dp[2][2] = true（'.' 任意字符，'*' 表示 0+ 次）
     */
    public boolean isMatch(String s, String p) {
        //还是动态规划吧
        int m  = s.length();
        int n = p.length();

        boolean[][] dp = new boolean[m + 1][n + 1];

        dp[0][0] = true;

        // 处理 s 为空时，p 能否匹配空串的情况：
        // 只有当模式形如 x* 可以被省略（表示 0 个 x），对应 j 从 2 开始并以 2 为步长处理
        for (int j = 2; j <= n; j += 2) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }

        // i 从 1..m, j 从 1..n 的典型填表顺序
        for(int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p.charAt(j - 1) == '*') {
                    // 情况 1：'*' 表示前面的元素出现 0 次 -> 忽略 x*
                    // 情况 2：'*' 表示前面的元素出现 >=1 次 -> 需要 s[i-1] 能和 p[j-2] 匹配，并且 dp[i-1][j] 为真
                    dp[i][j] = dp[i][j - 2] || (dp[i-1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
                } else {
                    // 普通字符或 '.'：需要当前字符匹配且之前前缀匹配
                    dp[i][j] = dp[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
                }
            }
        }
        return dp[m][n];
    }
}
