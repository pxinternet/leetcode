# 令牌桶 vs 漏桶：场景对比分析

## 核心区别

### 令牌桶（Token Bucket）
- **机制**：以固定速率**生成令牌**，请求消耗令牌
- **特点**：**允许突发流量**（桶中有令牌时）
- **输出**：输出速率可变，取决于请求速率和令牌数量

### 漏桶（Leaky Bucket）
- **机制**：请求**进入桶中**，以固定速率**流出**
- **特点**：**不允许突发流量**，输出速率恒定
- **输出**：输出速率恒定，不受输入影响

## 形象比喻

### 令牌桶 = 银行取款
- 银行每天给你固定额度（生成令牌）
- 你可以一次性取完所有额度（突发流量）
- 取完后需要等待第二天（等待令牌补充）

### 漏桶 = 水龙头接水
- 水龙头以固定速度流水（恒定输出）
- 无论你倒多少水进去（输入），流出的速度不变
- 桶满了就溢出（拒绝请求）

## 详细对比

| 特性 | 令牌桶 | 漏桶 |
|------|--------|------|
| **输入速率** | 可变 | 可变 |
| **输出速率** | 可变（取决于令牌数） | **恒定** |
| **突发流量** | ✅ **允许** | ❌ **不允许** |
| **流量平滑度** | 中等 | **最高** |
| **桶满时** | 拒绝新请求 | 拒绝新请求 |
| **桶空时** | 等待令牌补充 | 继续以固定速率流出 |

## 适用场景

### 🪙 令牌桶适用场景

#### 1. **API限流（最常用）**
```
场景：对外提供API服务
需求：允许用户偶尔突发请求，但长期平均速率受限
示例：用户平时请求很少，但某个时刻需要批量查询数据
```

**为什么适合？**
- 用户可以在短时间内发送多个请求（利用桶中积累的令牌）
- 长期来看，平均速率受限于令牌生成速率
- 用户体验好，不会因为偶尔的突发请求被拒绝

#### 2. **网络流量控制**
```
场景：网络带宽管理
需求：允许突发传输，但长期平均速率受限
示例：下载文件时，可以短时间内高速下载，但长期平均速率受限
```

#### 3. **缓存预热**
```
场景：系统启动时预热缓存
需求：允许短时间内大量请求，但平时限制速率
示例：系统重启后，可以快速加载热点数据
```

#### 4. **用户行为限流**
```
场景：限制用户操作频率
需求：允许用户偶尔快速操作，但防止恶意刷屏
示例：点赞、评论等操作，允许用户连续操作几次，但限制长期频率
```

### 🪣 漏桶适用场景

#### 1. **下游服务保护**
```
场景：保护下游服务不被突发流量压垮
需求：无论上游流量多大，下游接收速率恒定
示例：消息队列消费者，无论生产者发送多快，消费者以固定速率处理
```

**为什么适合？**
- 下游服务有固定的处理能力
- 需要平滑的流量，避免突发压力
- 保护下游服务的稳定性

#### 2. **数据库连接池**
```
场景：数据库查询限流
需求：无论应用层请求多快，数据库查询速率恒定
示例：防止大量并发查询导致数据库崩溃
```

#### 3. **日志写入**
```
场景：日志系统写入限流
需求：无论应用产生多少日志，写入磁盘的速率恒定
示例：防止日志写入过快导致磁盘IO瓶颈
```

#### 4. **第三方API调用**
```
场景：调用第三方API
需求：严格遵守第三方API的速率限制
示例：第三方API限制每秒10次调用，必须严格遵守
```

#### 5. **数据同步**
```
场景：数据同步任务
需求：无论源数据变化多快，同步速率恒定
示例：数据库主从同步，避免对从库造成过大压力
```

## 实际案例对比

### 案例1：API限流

**场景**：对外提供用户查询API，限制每秒100次请求

**使用令牌桶**：
```java
TokenBucketRateLimiter limiter = new TokenBucketRateLimiter(200, 100);
// 容量200，每秒补充100个令牌
```
- ✅ 用户可以在短时间内发送200个请求（突发）
- ✅ 长期平均速率限制在100/秒
- ✅ 用户体验好

**使用漏桶**：
```java
LeakyBucketRateLimiter limiter = new LeakyBucketRateLimiter(200, 100);
// 容量200，每秒流出100个请求
```
- ❌ 即使用户快速发送请求，也只能以100/秒的速率处理
- ❌ 用户体验差，无法利用突发能力

**结论**：✅ **令牌桶更适合**

### 案例2：消息队列消费者

**场景**：从消息队列消费消息，处理能力固定为每秒100条

**使用令牌桶**：
```java
TokenBucketRateLimiter limiter = new TokenBucketRateLimiter(200, 100);
```
- ❌ 如果消息队列突然涌入大量消息，可能超过处理能力
- ❌ 无法保护下游处理服务

**使用漏桶**：
```java
LeakyBucketRateLimiter limiter = new LeakyBucketRateLimiter(200, 100);
```
- ✅ 无论消息队列有多少消息，都以100/秒的速率处理
- ✅ 保护下游处理服务不被压垮

**结论**：✅ **漏桶更适合**

## 选择决策树

```
需要限制什么？
│
├─ 限制输入速率（允许突发）
│   └─ ✅ 令牌桶
│
└─ 限制输出速率（恒定输出）
    └─ ✅ 漏桶
```

## 总结

| 场景类型 | 推荐算法 | 原因 |
|---------|---------|------|
| **对外API限流** | 令牌桶 | 允许突发，用户体验好 |
| **用户行为限流** | 令牌桶 | 允许偶尔快速操作 |
| **下游服务保护** | 漏桶 | 恒定输出，保护下游 |
| **数据库限流** | 漏桶 | 恒定查询速率 |
| **日志写入** | 漏桶 | 恒定写入速率 |
| **第三方API调用** | 漏桶 | 严格遵守速率限制 |

## 记忆口诀

- **令牌桶**：允许突发，适合**对外服务**
- **漏桶**：恒定输出，适合**保护下游**
