设计文档：基于播放量统计 Top-K 电影

目标
- 从 CSV 文件中读取电影播放数据（每行包含电影名、播放数），统计播放量最高的 Top-K 电影。
- 要求：CSV 解析必须健壮，不能简单地按逗号 split，因为电影名可能包含逗号或换行，要支持双引号包裹的字段以及双引号内的转义（"" 表示一个引号）。
- 支持大文件流式处理，内存占用 O(K)（使用固定大小的堆）。

输入格式
- CSV 文件每行为一条记录，字段之间用逗号分隔，遵循一般 CSV 规范（RFC4180 风格）：
  - 字段可以不加引号，如: Avengers,100000
  - 字段如果包含逗号、换行或引号，需用双引号包裹，内部的双引号以两个双引号表示，如: "The Good, the Bad and the Ugly",12345
  - 允许字段包含换行（在双引号内）
  - 忽略 BOM（若存在）

输出
- 返回 Top-K 的电影列表，按播放量从高到低排序；若播放量相同，可按电影名字典序排序作为次要规则。
- 若文件行不足 K，返回全部电影按排序后的前若干项。

设计要点
1. CSV 解析器（关键）
   - 实现一个流式的、行-级别的解析器，但要能处理被双引号包裹并包含换行的字段。
   - 解析逻辑：逐行读取，但在解析过程中维护一个 ``inQuotes`` 状态；当未闭合引号时，继续读取下一行并把换行字符保留到字段中；处理连续两个双引号成为一个真实的双引号字符。
   - 返回 List<String> 表示一条记录的字段。

2. 流式 Top-K 计算
   - 使用最小堆（PriorityQueue）维护当前最大的 K 个电影（基于播放数）。
   - 处理每一条记录：取电影名（第 1 列）与播放数（第 2 列），将播放数累加到 movie -> count 的映射中（如果存在重复电影名，则合并播放数）。
   - 为了节省空间，不需要保存所有电影到内存中，但若需要合并同名电影，则需要一个 Map 来累积播放量，这会使内存 O(N)（N 为不同电影数）。
   - 备选：如果文件非常大且电影名重复不多，可在单次扫描中进行分块、外部排序或使用流式 Top-K 算法（如使用可持久化哈希或 Count-Min Sketch）。为了实现简单且适合中小规模数据，这里用 HashMap 累加播放量，然后用 Heap 选 Top-K。

3. 错误处理
   - 忽略解析失败的行并在 stderr 输出警告（或计数）。
   - 对播放数解析异常（非数字）要跳过或视为 0，并记录日志。

4. 扩展与优化
   - 若需要支持非常大数据（无法把所有电影名放到内存），可以采用两阶段外部算法：第一阶段把数据按哈希分桶写到磁盘（例如按 movieName 的哈希 % M），每个桶足够小可以在内存中处理；第二阶段对每个桶分别统计并输出局部 Top-K，再合并这些局部 Top-K 得到全局 Top-K（类似 MapReduce 的思想）。
   - 还可使用近似流算法（Count-Min Sketch + heap）来降低内存，但会有误差。

接口与使用示例
- 命令行示例：
  java -cp out TopKMovies path/to/movies.csv 10

实现语言
- Java（单文件实现，易于集成到现有仓库），无外部依赖，CSV 解析器自实现。

测试用例
- 普通 CSV
- 电影名含逗号："Hello, World",123
- 电影名含换行："Multi\nLine Movie",456
- 电影名含引号："He said ""Hi""",789
- 非法播放数：Some Movie,not_a_number -> 应跳过或记录错误



实现说明文档结束。

